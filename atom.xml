<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>立志不坚，终不济事</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cai1001.github.io/"/>
  <updated>2019-11-27T03:38:54.838Z</updated>
  <id>https://cai1001.github.io/</id>
  
  <author>
    <name>Albert</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习课程资源</title>
    <link href="https://cai1001.github.io/2019/11/27/2019-11-27/"/>
    <id>https://cai1001.github.io/2019/11/27/2019-11-27/</id>
    <published>2019-11-27T03:35:22.000Z</published>
    <updated>2019-11-27T03:38:54.838Z</updated>
    
    <content type="html"><![CDATA[<h4 id="林宏毅深度学习资料"><a href="#林宏毅深度学习资料" class="headerlink" title="林宏毅深度学习资料"></a>林宏毅深度学习资料</h4><p>林宏毅 主页</p><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/index.html" target="_blank" rel="noopener">http://speech.ee.ntu.edu.tw/~tlkagk/index.html</a></p><p>李宏毅机器学习(2017)<br><a href="https://www.bilibili.com/video/av10590361?from=search&amp;seid=456509998694502607" target="_blank" rel="noopener">https://www.bilibili.com/video/av10590361?from=search&amp;seid=456509998694502607</a><br>李宏毅深度学习(2017)<br><a href="https://www.bilibili.com/video/av9770302?from=search&amp;seid=456509998694502607" target="_blank" rel="noopener">https://www.bilibili.com/video/av9770302?from=search&amp;seid=456509998694502607</a></p><p>李宏毅2017 深度学习GAN课程<br><a href="https://www.bilibili.com/video/av18603573?from=search&amp;seid=456509998694502607" target="_blank" rel="noopener">https://www.bilibili.com/video/av18603573?from=search&amp;seid=456509998694502607</a></p><p>李宏毅深度学习合辑 Advanced Topics in Deep Learning</p><p><a href="https://www.bilibili.com/video/av19145699?from=search&amp;seid=456509998694502607" target="_blank" rel="noopener">https://www.bilibili.com/video/av19145699?from=search&amp;seid=456509998694502607</a></p><p>深度学习 李宏毅 深度学习理论 Deep Learning Theory<br><a href="https://www.bilibili.com/video/av20961661?from=search&amp;seid=4753772315676173168" target="_blank" rel="noopener">https://www.bilibili.com/video/av20961661?from=search&amp;seid=4753772315676173168</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;林宏毅深度学习资料&quot;&gt;&lt;a href=&quot;#林宏毅深度学习资料&quot; class=&quot;headerlink&quot; title=&quot;林宏毅深度学习资料&quot;&gt;&lt;/a&gt;林宏毅深度学习资料&lt;/h4&gt;&lt;p&gt;林宏毅 主页&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://speech.ee.nt
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cai1001.github.io//categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="资源" scheme="https://cai1001.github.io//tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Bert模型入门</title>
    <link href="https://cai1001.github.io/2019/11/26/2019-11-26-11-49/"/>
    <id>https://cai1001.github.io/2019/11/26/2019-11-26-11-49/</id>
    <published>2019-11-26T03:49:27.000Z</published>
    <updated>2019-11-26T03:56:53.283Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是BERT"><a href="#什么是BERT" class="headerlink" title="什么是BERT"></a>什么是BERT</h4><p>传统的word embedding的预训练表示是上下文无关的（word2vec）</p><ul><li>bank deposite (银行) VS river bank (河岸)</li></ul><p>BERT: bidirectional encoder representations from transformers</p><ul><li>BERT是一种预训练的语言表示的方法，上下文相关。</li></ul><h4 id="Attention机制"><a href="#Attention机制" class="headerlink" title="Attention机制"></a>Attention机制</h4><h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是BERT&quot;&gt;&lt;a href=&quot;#什么是BERT&quot; class=&quot;headerlink&quot; title=&quot;什么是BERT&quot;&gt;&lt;/a&gt;什么是BERT&lt;/h4&gt;&lt;p&gt;传统的word embedding的预训练表示是上下文无关的（word2vec）&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="教程" scheme="https://cai1001.github.io//categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="模型" scheme="https://cai1001.github.io//tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深度学习框架</title>
    <link href="https://cai1001.github.io/2019/11/25/2019-11-25-11-43/"/>
    <id>https://cai1001.github.io/2019/11/25/2019-11-25-11-43/</id>
    <published>2019-11-25T03:43:28.000Z</published>
    <updated>2019-11-25T06:42:36.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h3><table><thead><tr><th>深度学习框架</th><th>公司</th><th></th></tr></thead><tbody><tr><td>Tensorflow</td><td>Google</td><td></td></tr><tr><td>Pytorch</td><td>Facebook</td><td></td></tr><tr><td>caffe</td><td></td><td></td></tr><tr><td>Theano</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="TensorFlow-Google"><a href="#TensorFlow-Google" class="headerlink" title="TensorFlow(Google)"></a>TensorFlow(Google)</h4><ul><li>TensorFlow生态系统有三个主要组成<ul><li>用C ++编写的<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow API</a>包含用于定义模型和使用数据训练模型的API。 它也有一个用户友好的Python接口。</li><li><a href="https://github.com/tensorflow/tensorboard" target="_blank" rel="noopener">TensorBoard</a>是一个可视化工具包，可帮助分析，可视化和调试TensorFlow计算图。</li><li><a href="https://github.com/tensorflow/serving" target="_blank" rel="noopener">TensorFlow Serving</a>是一种灵活的高性能服务系统，用于在生产环境中部署预先训练好的机器学习模型。Serving也是由C ++编写并可通过Python接口访问，可以即时从旧模式切换到新模式。</li></ul></li><li>计算图 和 会话</li></ul><h4 id="Theano-（蒙特利尔大学）"><a href="#Theano-（蒙特利尔大学）" class="headerlink" title=" Theano （蒙特利尔大学）"></a> Theano （蒙特利尔大学）</h4><p><a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a>是另一个用于快速数值计算的Python库，可以在CPU或GPU上运行。它是由机器学习三大佬之一的Youshua Bengio所负责的<a href="https://mila.quebec/en/" target="_blank" rel="noopener">蒙特利尔大学蒙特利尔学习算法小组</a>开发的一个开源项目。Youshua Bengio（MILA实验室负责人）在2017年11月宣布他们将不再积极维护或开发Theano。</p><h4 id="PyTorch-Facebook"><a href="#PyTorch-Facebook" class="headerlink" title="PyTorch (Facebook)"></a>PyTorch (Facebook)</h4><ul><li>PyTorch有3个抽象层次：<ul><li><strong>张量</strong>：命令性的ndarray，但在GPU上运行</li><li><strong>变量</strong>：计算图中的节点;存储数据和梯度</li><li><strong>模块</strong>：神经网络层;可以存储状态或可学习的权重</li></ul></li></ul><h4 id="Torch-NYU-Facebook"><a href="#Torch-NYU-Facebook" class="headerlink" title="Torch (NYU / Facebook)"></a><strong>Torch (NYU / Facebook)</strong></h4><ul><li>它是Facebook的<a href="https://github.com/torch/torch7" target="_blank" rel="noopener">开源机器学习库</a>、<a href="http://torch.ch/" target="_blank" rel="noopener">科学计算框架</a>和基于<a href="https://github.com/torch/nn" target="_blank" rel="noopener">Lua编程语言的脚本语言</a>。Pytorch的祖先，Torch只有2个：<strong>张量</strong>和<strong>模块</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深度学习框架&quot;&gt;&lt;a href=&quot;#深度学习框架&quot; class=&quot;headerlink&quot; title=&quot;深度学习框架&quot;&gt;&lt;/a&gt;深度学习框架&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;深度学习框架&lt;/th&gt;
&lt;th&gt;公司&lt;/th&gt;
&lt;th&gt;&lt;/th
      
    
    </summary>
    
    
      <category term="博客" scheme="https://cai1001.github.io//categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="深度学习" scheme="https://cai1001.github.io//tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款13、14、15</title>
    <link href="https://cai1001.github.io/2019/11/25/2019-11-25/"/>
    <id>https://cai1001.github.io/2019/11/25/2019-11-25/</id>
    <published>2019-11-25T02:38:58.000Z</published>
    <updated>2019-11-25T03:33:16.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="条款13-以对象管理资源"><a href="#条款13-以对象管理资源" class="headerlink" title="条款13 以对象管理资源"></a>条款13 以对象管理资源</h3><ul><li>获得资源后立刻放进管理对象内</li><li>管理对象运用析构函数确保资源释被释放</li><li>如果使用智能指针进行资源管理，那么注意不要使用多个auto_ptr指向同一个对象，否则对象会被删除多次，导致程序出现“未定义行为”。对此智能指针有一个性质：如果调用copy构造函数，和copy assignment操作符来复制它们，它们本身会变成null，而赋值所得的指针将获得资源的唯一拥有权。</li><li>引用计数型智慧指针，无法解决环状引用的问题。</li></ul><h3 id="条款14-在资源管理类中小心copying行为"><a href="#条款14-在资源管理类中小心copying行为" class="headerlink" title="条款14 在资源管理类中小心copying行为"></a>条款14 在资源管理类中小心copying行为</h3><p>复制RAII对象需要同时复制它所管理的资源，所以资源的copying行为决定了RAII对象的copying行为。</p><p>普遍常见的RAII class copying行为是：抑制copying （声明private copying method）、使用引用计数法（shared_ptr）</p><h3 id="条款15-在资源管理类中提供对原始资源的访问"><a href="#条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15 在资源管理类中提供对原始资源的访问"></a>条款15 在资源管理类中提供对原始资源的访问</h3>]]></content>
    
    <summary type="html">
    
      资源管理，当你不尝试使用资源的时候，必须将其归还给系统。
    
    </summary>
    
    
      <category term="笔记" scheme="https://cai1001.github.io//categories/notes/"/>
    
    
      <category term="C++" scheme="https://cai1001.github.io//tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 笔记</title>
    <link href="https://cai1001.github.io/2019/11/24/2019-11-24/"/>
    <id>https://cai1001.github.io/2019/11/24/2019-11-24/</id>
    <published>2019-11-24T09:01:31.000Z</published>
    <updated>2019-11-24T12:12:54.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="条款10-令operator-返回一个reference-to-this"><a href="#条款10-令operator-返回一个reference-to-this" class="headerlink" title="条款10 令operator = 返回一个reference to *this"></a>条款10 令operator = 返回一个reference to *this</h3><p>c++赋值可以写成连锁的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y = z = <span class="number">15</span>;    <span class="comment">// x = (y = ( z = 15));</span></span><br></pre></td></tr></table></figure><p>这个规则是一个约定，无强制性，标准程序库例如 string, vector, complex等 共同遵守的规则。</p><h3 id="条款11-在operator-中处理“自我赋值”"><a href="#条款11-在operator-中处理“自我赋值”" class="headerlink" title="条款11 在operator = 中处理“自我赋值”"></a>条款11 在operator = 中处理“自我赋值”</h3><p>对象赋值：释放原有的对象，然后通过调用赋值的对象的构造函数，返回赋值对象的副本的引用。</p><p>潜在问题：赋值对象 和 被赋值对象是同一个对象的时候，如果先释放被赋值对象就会导致赋值对象也被释放，此时需要先证同，在赋值对象和被赋值对象是同一个的时候。</p><p>方案1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;pb;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题： 如果 在new Bitmap截断出现异常（分配内存不足 或 Bitmap的copy构造函数异常）Widget最终会持有一个指针指向一块被删除的Bitmap。这样的指针有害。</p><p>方案2</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">Bitmap* pOrig = pb;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">  <span class="keyword">delete</span> pOrig;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案3 copy-and-swap 技术</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">Widget temp(<span class="keyword">this</span>);</span><br><span class="line">swap(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款12-复制对象时勿忘复制其每一部分"><a href="#条款12-复制对象时勿忘复制其每一部分" class="headerlink" title="条款12 复制对象时勿忘复制其每一部分"></a>条款12 复制对象时勿忘复制其每一部分</h3><p>如果你声明自己的copying 函数，意思就是告诉编译器你不喜欢使用缺省实现的某些行为。编译器也会在你的代码几乎出错时，也不会提示。</p><p>当我们自己声明一个copying构造函数，确保（1）赋值所有的local成员变量 （2）调用所有base classes内的适当的copying函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;条款10-令operator-返回一个reference-to-this&quot;&gt;&lt;a href=&quot;#条款10-令operator-返回一个reference-to-this&quot; class=&quot;headerlink&quot; title=&quot;条款10 令operator = 返回一
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://cai1001.github.io//categories/notes/"/>
    
    
      <category term="C++" scheme="https://cai1001.github.io//tags/c/"/>
    
  </entry>
  
</feed>
