<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>立志不坚，终不济事</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cai1001.github.io/"/>
  <updated>2019-12-19T02:53:18.297Z</updated>
  <id>https://cai1001.github.io/</id>
  
  <author>
    <name>Albert</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Awesome CS courses</title>
    <link href="https://cai1001.github.io/2019/12/19/cs-courses/"/>
    <id>https://cai1001.github.io/2019/12/19/cs-courses/</id>
    <published>2019-12-19T02:23:14.000Z</published>
    <updated>2019-12-19T02:53:18.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><h4 id="CS-61C-Great-Ideas-in-Computer-Architecture-Machine-Structures-UC-Berkeley"><a href="#CS-61C-Great-Ideas-in-Computer-Architecture-Machine-Structures-UC-Berkeley" class="headerlink" title="CS 61C Great Ideas in Computer Architecture (Machine Structures) UC Berkeley"></a>CS 61C Great Ideas in Computer Architecture (Machine Structures) UC Berkeley</h4><p>课程覆盖了 C 语言、汇编语言（MIPS 指令集）、CPU 设计（包括逻辑电路/Cache/流水线）、内存管理、并发编程、数据中心(Warehouse-Scale Computer)等话题，内容偏基础，老师讲得非常棒。</p><p><a href="http://www-inst.eecs.berkeley.edu/~cs61c/sp15/" target="_blank" rel="noopener">课程主页</a><br><a href="https://www.bilibili.com/video/av40428315/" target="_blank" rel="noopener">课程视频</a><br><a href="https://zhjwpku.com/assets/pdf/ComputerOrganizationAndDesign5thEdition2014.pdf" target="_blank" rel="noopener">教材Computer Organization And Design 5th Edition</a><br><a href="https://hkn.eecs.berkeley.edu/exams/course/CS/61C" target="_blank" rel="noopener">试题</a></p><h4 id="15-213-Introduction-to-Computer-Systems-CMU"><a href="#15-213-Introduction-to-Computer-Systems-CMU" class="headerlink" title="15-213 Introduction to Computer Systems CMU"></a>15-213 Introduction to Computer Systems CMU</h4><p>ICS 能让你成为更高效的程序员，特别是在处理性能，可移植性和健壮性问题时。BTW，15213 是 CMU 的邮编。<br><a href="http://www.cs.cmu.edu/~213/index.html" target="_blank" rel="noopener">课程主页</a><br><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22&view=2" target="_blank" rel="noopener">课程视频</a><br><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="noopener">教材Computer Systems: A Programmer’s Perspective</a></p><h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><h4 id="CS106A-Programming-Methodology-Spring-2017-Stanford"><a href="#CS106A-Programming-Methodology-Spring-2017-Stanford" class="headerlink" title="CS106A Programming Methodology, Spring 2017 Stanford"></a>CS106A <strong>Programming Methodology, Spring 2017</strong> <em>Stanford</em></h4><p>编程方法论是编程入门课程中最大的课程，也是斯坦福大学最大的课程之一。该课程使用 <strong>Java</strong> 语言着重介绍了现代软件工程原理：面向对象的设计，分解，封装，继承，多态等。课程相对简单，为了衔接之后的 <a href="http://stanford.edu/class/archive/cs/cs106b/cs106b.1184/index.shtml" target="_blank" rel="noopener">CS 106B</a>，笔者把所有的课程视频浏览了一遍。<br><a href="http://web.stanford.edu/class/cs106a/" target="_blank" rel="noopener">课程主页</a><br><a href="https://www.bilibili.com/video/av36204486/" target="_blank" rel="noopener">视频教程</a></p><h4 id="CS-106B-Programming-Abstractions-Winter-2018-Stanford"><a href="#CS-106B-Programming-Abstractions-Winter-2018-Stanford" class="headerlink" title="CS 106B Programming Abstractions, Winter 2018 Stanford"></a>CS 106B Programming Abstractions, Winter 2018 Stanford</h4><p>该课程是编程方法论的自然继承，使用 C++ 语言教学，涵盖了递归，算法分析和数据抽象等高级编程主题。<br><a href="https://zhjwpku.com/assets/pdf/books/Programming.Abstractions.in.CPP.pdf" target="_blank" rel="noopener">教材 Programming Abstractions in C++</a></p><h4 id="CS106X-Programming-Abstractions-Accelerated-Stanford"><a href="#CS106X-Programming-Abstractions-Accelerated-Stanford" class="headerlink" title="CS106X Programming Abstractions (Accelerated)Stanford"></a>CS106X Programming Abstractions (Accelerated)Stanford</h4><p>课程 106X 覆盖的内容与 106B 相同，使用 <strong>C++</strong>，但教授的速度更快，层次更深。<br><a href="http://web.stanford.edu/class/cs106x/" target="_blank" rel="noopener">课程主页</a><br><a href="https://www.bilibili.com/video/av21619854" target="_blank" rel="noopener">课程视频</a></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>MIT算法导论<br><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" target="_blank" rel="noopener">课程主页</a><br><a href="https://www.bilibili.com/video/av66468649?from=search&seid=7975302138455190356" target="_blank" rel="noopener">教程视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统&quot;&gt;&lt;a href=&quot;#计算机系统&quot; class=&quot;headerlink&quot; title=&quot;计算机系统&quot;&gt;&lt;/a&gt;计算机系统&lt;/h2&gt;&lt;h4 id=&quot;CS-61C-Great-Ideas-in-Computer-Architecture-Machine-S
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://cai1001.github.io//categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="资源" scheme="https://cai1001.github.io//tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>linux 鸟哥的私房菜 -- 笔记</title>
    <link href="https://cai1001.github.io/2019/12/11/linux/"/>
    <id>https://cai1001.github.io/2019/12/11/linux/</id>
    <published>2019-12-11T02:03:44.000Z</published>
    <updated>2019-12-11T02:14:26.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机硬件的五大单元"><a href="#计算机硬件的五大单元" class="headerlink" title="计算机硬件的五大单元"></a>计算机硬件的五大单元</h3><p>工作流程是</p><p>【图片摘自《鸟哥的私房菜》】</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机硬件的五大单元&quot;&gt;&lt;a href=&quot;#计算机硬件的五大单元&quot; class=&quot;headerlink&quot; title=&quot;计算机硬件的五大单元&quot;&gt;&lt;/a&gt;计算机硬件的五大单元&lt;/h3&gt;&lt;p&gt;工作流程是&lt;/p&gt;
&lt;p&gt;【图片摘自《鸟哥的私房菜》】&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="linux" scheme="https://cai1001.github.io//tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>NLP 论文集合</title>
    <link href="https://cai1001.github.io/2019/11/28/nlp-papers/"/>
    <id>https://cai1001.github.io/2019/11/28/nlp-papers/</id>
    <published>2019-11-28T02:39:21.000Z</published>
    <updated>2019-11-28T02:57:17.454Z</updated>
    
    <content type="html"><![CDATA[<p>2014年经典Seq2Seq模型【Sequence to Sequence Learning with Neural Networks】</p><p><a href="https://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">https://arxiv.org/abs/1409.3215</a></p><p>2015年机器翻文章译拉开attention机制的序幕【Neural Machine Translation by Jointly Learning to Align and Translate】</p><p><a href="https://arxiv.org/abs/1409.0473" target="_blank" rel="noopener">https://arxiv.org/abs/1409.0473</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2014年经典Seq2Seq模型【Sequence to Sequence Learning with Neural Networks】&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1409.3215&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="资源" scheme="https://cai1001.github.io//categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="论文" scheme="https://cai1001.github.io//tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>深度学习课程资源</title>
    <link href="https://cai1001.github.io/2019/11/27/2019-11-27/"/>
    <id>https://cai1001.github.io/2019/11/27/2019-11-27/</id>
    <published>2019-11-27T03:35:22.000Z</published>
    <updated>2019-12-24T09:27:38.833Z</updated>
    
    <content type="html"><![CDATA[<h4 id="林宏毅深度学习资料"><a href="#林宏毅深度学习资料" class="headerlink" title="林宏毅深度学习资料"></a>林宏毅深度学习资料</h4><p>林宏毅 主页</p><p><a href="http://speech.ee.ntu.edu.tw/~tlkagk/index.html" target="_blank" rel="noopener">http://speech.ee.ntu.edu.tw/~tlkagk/index.html</a></p><p>李宏毅机器学习(2017)<br><a href="https://www.bilibili.com/video/av10590361?from=search&amp;seid=456509998694502607" target="_blank" rel="noopener">https://www.bilibili.com/video/av10590361?from=search&amp;seid=456509998694502607</a><br>李宏毅深度学习(2017)<br><a href="https://www.bilibili.com/video/av9770302?from=search&amp;seid=456509998694502607" target="_blank" rel="noopener">https://www.bilibili.com/video/av9770302?from=search&amp;seid=456509998694502607</a></p><p>李宏毅2017 深度学习GAN课程<br><a href="https://www.bilibili.com/video/av18603573?from=search&amp;seid=456509998694502607" target="_blank" rel="noopener">https://www.bilibili.com/video/av18603573?from=search&amp;seid=456509998694502607</a></p><p>李宏毅深度学习合辑 Advanced Topics in Deep Learning</p><p><a href="https://www.bilibili.com/video/av19145699?from=search&amp;seid=456509998694502607" target="_blank" rel="noopener">https://www.bilibili.com/video/av19145699?from=search&amp;seid=456509998694502607</a></p><p>深度学习 李宏毅 深度学习理论 Deep Learning Theory<br><a href="https://www.bilibili.com/video/av20961661?from=search&amp;seid=4753772315676173168" target="_blank" rel="noopener">https://www.bilibili.com/video/av20961661?from=search&amp;seid=4753772315676173168</a></p><p>李沐 动手深度学习</p><p><a href="https://www.bilibili.com/video/av63439164?from=search&seid=8457518055160417798" target="_blank" rel="noopener">视频教程</a></p><p><a href="http://zh.d2l.ai/" target="_blank" rel="noopener">MXNet</a></p><p><a href="https://github.com/dsgiitr/d2l-pytorch" target="_blank" rel="noopener">pytorch版本</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;林宏毅深度学习资料&quot;&gt;&lt;a href=&quot;#林宏毅深度学习资料&quot; class=&quot;headerlink&quot; title=&quot;林宏毅深度学习资料&quot;&gt;&lt;/a&gt;林宏毅深度学习资料&lt;/h4&gt;&lt;p&gt;林宏毅 主页&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://speech.ee.nt
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://cai1001.github.io//categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="资源" scheme="https://cai1001.github.io//tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Bert模型入门</title>
    <link href="https://cai1001.github.io/2019/11/26/2019-11-26-11-49/"/>
    <id>https://cai1001.github.io/2019/11/26/2019-11-26-11-49/</id>
    <published>2019-11-26T03:49:27.000Z</published>
    <updated>2019-11-28T02:35:25.316Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是BERT"><a href="#什么是BERT" class="headerlink" title="什么是BERT"></a>什么是BERT</h4><p>传统的word embedding的预训练表示是上下文无关的（word2vec）</p><ul><li>bank deposite (银行) VS river bank (河岸)</li></ul><p>BERT: bidirectional encoder representations from transformers</p><ul><li>BERT是一种预训练的语言表示的方法，上下文相关。</li></ul><h4 id="Attention机制"><a href="#Attention机制" class="headerlink" title="Attention机制"></a>Attention机制</h4><p>深度学习中的注意力机制可以理解为表示重要性的权重向量。</p><p>为了预测或推断一个元素，例如图像中的像素或句子中的单词，我们使用注意力权重来估计其他元素与其相关的强度，并将由注意力权重加权的值的总和作为计算最终目标的特征。</p><ul><li>计算其他元素与待预测元素的相关性权重</li><li>根据相关性权重对其他元素进行加权求和</li></ul><h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是BERT&quot;&gt;&lt;a href=&quot;#什么是BERT&quot; class=&quot;headerlink&quot; title=&quot;什么是BERT&quot;&gt;&lt;/a&gt;什么是BERT&lt;/h4&gt;&lt;p&gt;传统的word embedding的预训练表示是上下文无关的（word2vec）&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="教程" scheme="https://cai1001.github.io//categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="模型" scheme="https://cai1001.github.io//tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深度学习框架</title>
    <link href="https://cai1001.github.io/2019/11/25/2019-11-25-11-43/"/>
    <id>https://cai1001.github.io/2019/11/25/2019-11-25-11-43/</id>
    <published>2019-11-25T03:43:28.000Z</published>
    <updated>2019-11-25T06:42:36.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h3><table><thead><tr><th>深度学习框架</th><th>公司</th><th></th></tr></thead><tbody><tr><td>Tensorflow</td><td>Google</td><td></td></tr><tr><td>Pytorch</td><td>Facebook</td><td></td></tr><tr><td>caffe</td><td></td><td></td></tr><tr><td>Theano</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="TensorFlow-Google"><a href="#TensorFlow-Google" class="headerlink" title="TensorFlow(Google)"></a>TensorFlow(Google)</h4><ul><li>TensorFlow生态系统有三个主要组成<ul><li>用C ++编写的<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow API</a>包含用于定义模型和使用数据训练模型的API。 它也有一个用户友好的Python接口。</li><li><a href="https://github.com/tensorflow/tensorboard" target="_blank" rel="noopener">TensorBoard</a>是一个可视化工具包，可帮助分析，可视化和调试TensorFlow计算图。</li><li><a href="https://github.com/tensorflow/serving" target="_blank" rel="noopener">TensorFlow Serving</a>是一种灵活的高性能服务系统，用于在生产环境中部署预先训练好的机器学习模型。Serving也是由C ++编写并可通过Python接口访问，可以即时从旧模式切换到新模式。</li></ul></li><li>计算图 和 会话</li></ul><h4 id="Theano-（蒙特利尔大学）"><a href="#Theano-（蒙特利尔大学）" class="headerlink" title=" Theano （蒙特利尔大学）"></a> Theano （蒙特利尔大学）</h4><p><a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a>是另一个用于快速数值计算的Python库，可以在CPU或GPU上运行。它是由机器学习三大佬之一的Youshua Bengio所负责的<a href="https://mila.quebec/en/" target="_blank" rel="noopener">蒙特利尔大学蒙特利尔学习算法小组</a>开发的一个开源项目。Youshua Bengio（MILA实验室负责人）在2017年11月宣布他们将不再积极维护或开发Theano。</p><h4 id="PyTorch-Facebook"><a href="#PyTorch-Facebook" class="headerlink" title="PyTorch (Facebook)"></a>PyTorch (Facebook)</h4><ul><li>PyTorch有3个抽象层次：<ul><li><strong>张量</strong>：命令性的ndarray，但在GPU上运行</li><li><strong>变量</strong>：计算图中的节点;存储数据和梯度</li><li><strong>模块</strong>：神经网络层;可以存储状态或可学习的权重</li></ul></li></ul><h4 id="Torch-NYU-Facebook"><a href="#Torch-NYU-Facebook" class="headerlink" title="Torch (NYU / Facebook)"></a><strong>Torch (NYU / Facebook)</strong></h4><ul><li>它是Facebook的<a href="https://github.com/torch/torch7" target="_blank" rel="noopener">开源机器学习库</a>、<a href="http://torch.ch/" target="_blank" rel="noopener">科学计算框架</a>和基于<a href="https://github.com/torch/nn" target="_blank" rel="noopener">Lua编程语言的脚本语言</a>。Pytorch的祖先，Torch只有2个：<strong>张量</strong>和<strong>模块</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深度学习框架&quot;&gt;&lt;a href=&quot;#深度学习框架&quot; class=&quot;headerlink&quot; title=&quot;深度学习框架&quot;&gt;&lt;/a&gt;深度学习框架&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;深度学习框架&lt;/th&gt;
&lt;th&gt;公司&lt;/th&gt;
&lt;th&gt;&lt;/th
      
    
    </summary>
    
    
      <category term="博客" scheme="https://cai1001.github.io//categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="深度学习" scheme="https://cai1001.github.io//tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 条款13、14、15</title>
    <link href="https://cai1001.github.io/2019/11/25/2019-11-25/"/>
    <id>https://cai1001.github.io/2019/11/25/2019-11-25/</id>
    <published>2019-11-25T02:38:58.000Z</published>
    <updated>2019-11-25T03:33:16.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="条款13-以对象管理资源"><a href="#条款13-以对象管理资源" class="headerlink" title="条款13 以对象管理资源"></a>条款13 以对象管理资源</h3><ul><li>获得资源后立刻放进管理对象内</li><li>管理对象运用析构函数确保资源释被释放</li><li>如果使用智能指针进行资源管理，那么注意不要使用多个auto_ptr指向同一个对象，否则对象会被删除多次，导致程序出现“未定义行为”。对此智能指针有一个性质：如果调用copy构造函数，和copy assignment操作符来复制它们，它们本身会变成null，而赋值所得的指针将获得资源的唯一拥有权。</li><li>引用计数型智慧指针，无法解决环状引用的问题。</li></ul><h3 id="条款14-在资源管理类中小心copying行为"><a href="#条款14-在资源管理类中小心copying行为" class="headerlink" title="条款14 在资源管理类中小心copying行为"></a>条款14 在资源管理类中小心copying行为</h3><p>复制RAII对象需要同时复制它所管理的资源，所以资源的copying行为决定了RAII对象的copying行为。</p><p>普遍常见的RAII class copying行为是：抑制copying （声明private copying method）、使用引用计数法（shared_ptr）</p><h3 id="条款15-在资源管理类中提供对原始资源的访问"><a href="#条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15 在资源管理类中提供对原始资源的访问"></a>条款15 在资源管理类中提供对原始资源的访问</h3>]]></content>
    
    <summary type="html">
    
      资源管理，当你不尝试使用资源的时候，必须将其归还给系统。
    
    </summary>
    
    
      <category term="笔记" scheme="https://cai1001.github.io//categories/notes/"/>
    
    
      <category term="C++" scheme="https://cai1001.github.io//tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 笔记</title>
    <link href="https://cai1001.github.io/2019/11/24/2019-11-24/"/>
    <id>https://cai1001.github.io/2019/11/24/2019-11-24/</id>
    <published>2019-11-24T09:01:31.000Z</published>
    <updated>2019-11-24T12:12:54.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="条款10-令operator-返回一个reference-to-this"><a href="#条款10-令operator-返回一个reference-to-this" class="headerlink" title="条款10 令operator = 返回一个reference to *this"></a>条款10 令operator = 返回一个reference to *this</h3><p>c++赋值可以写成连锁的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y = z = <span class="number">15</span>;    <span class="comment">// x = (y = ( z = 15));</span></span><br></pre></td></tr></table></figure><p>这个规则是一个约定，无强制性，标准程序库例如 string, vector, complex等 共同遵守的规则。</p><h3 id="条款11-在operator-中处理“自我赋值”"><a href="#条款11-在operator-中处理“自我赋值”" class="headerlink" title="条款11 在operator = 中处理“自我赋值”"></a>条款11 在operator = 中处理“自我赋值”</h3><p>对象赋值：释放原有的对象，然后通过调用赋值的对象的构造函数，返回赋值对象的副本的引用。</p><p>潜在问题：赋值对象 和 被赋值对象是同一个对象的时候，如果先释放被赋值对象就会导致赋值对象也被释放，此时需要先证同，在赋值对象和被赋值对象是同一个的时候。</p><p>方案1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;pb;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题： 如果 在new Bitmap截断出现异常（分配内存不足 或 Bitmap的copy构造函数异常）Widget最终会持有一个指针指向一块被删除的Bitmap。这样的指针有害。</p><p>方案2</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">Bitmap* pOrig = pb;</span><br><span class="line">  <span class="keyword">this</span>-&gt;pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">  <span class="keyword">delete</span> pOrig;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案3 copy-and-swap 技术</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">Widget temp(<span class="keyword">this</span>);</span><br><span class="line">swap(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条款12-复制对象时勿忘复制其每一部分"><a href="#条款12-复制对象时勿忘复制其每一部分" class="headerlink" title="条款12 复制对象时勿忘复制其每一部分"></a>条款12 复制对象时勿忘复制其每一部分</h3><p>如果你声明自己的copying 函数，意思就是告诉编译器你不喜欢使用缺省实现的某些行为。编译器也会在你的代码几乎出错时，也不会提示。</p><p>当我们自己声明一个copying构造函数，确保（1）赋值所有的local成员变量 （2）调用所有base classes内的适当的copying函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;条款10-令operator-返回一个reference-to-this&quot;&gt;&lt;a href=&quot;#条款10-令operator-返回一个reference-to-this&quot; class=&quot;headerlink&quot; title=&quot;条款10 令operator = 返回一
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://cai1001.github.io//categories/notes/"/>
    
    
      <category term="C++" scheme="https://cai1001.github.io//tags/c/"/>
    
  </entry>
  
</feed>
